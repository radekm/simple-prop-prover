-- |
-- Module    : Main
-- Copyright : (c) Radek Micek 2010
-- License   : BSD3
-- Stability : experimental
--
-- Checks whether proofs generated by PropProver are correct.
module Main where

import Control.Applicative ((<$>))
import Data.List
import Data.Maybe (fromJust)
import CNFParser
import qualified Data.IntMap as IM
import System.Environment (getArgs, getProgName)

-- Sorts literals in the clause.
normalizeClause :: StrClause -> StrClause
normalizeClause = StrClause . sort . scLits

-- One step of the proof.
data Step = Assumption Int StrClause
          | Resolution Int StrClause Int Int VarName

-- Decodes given string into step.
parseStep :: String -> Step
parseStep line = case words line of
    [clauseId, clause, _dashes, _assumption]
        -> Assumption (read clauseId) (readClause clause)
    [clauseId, clause, _dashes, _resolution, rId, rId', _on, varName]
        -> Resolution (read clauseId) (readClause clause)
                      (read $ init rId) (read rId') varName
    _   -> error "parseStep: invalid step"
  where
      readClause unparsedCl = case parseStrCNF unparsedCl of
          Right [cl] -> normalizeClause cl
          _          -> error "parseStep: cannot parse clause"

resolution :: StrClause -> StrClause -> VarName -> StrClause
resolution (StrClause lits) (StrClause lits') var
    | p `elem` lits && n `elem` lits' = resolve lits  lits'
    | n `elem` lits && p `elem` lits' = resolve lits' lits
    | otherwise                       = error "resolution: unable to resolve"
  where
      p = (var, True)
      n = (var, False)

      resolve l l' = StrClause $ sort $ nub $ (delete p l) ++ (delete n l')

-- First parameter is list with assumptions.
-- Returns line with invalid step.
check :: [StrClause] -> IM.IntMap StrClause -> [String] -> Maybe String
check _ _ [] = Nothing
check assumpts proved (l:ls) = case parseStep l of
    Assumption cId cl              -> validateAssumption cId cl
    Resolution cId cl rId rId' var -> validateResolution cId cl rId rId' var
  where
      validateAssumption cId cl
          | cl `elem` assumpts = check assumpts (IM.insert cId cl proved) ls
          | otherwise          = Just l

      validateResolution cId cl rId rId' varName
          | resolved == cl = check assumpts (IM.insert cId cl proved) ls
          | otherwise      = Just l
        where
            r        = fromJust $ IM.lookup rId  proved
            r'       = fromJust $ IM.lookup rId' proved
            resolved = resolution r r' varName

main :: IO ()       
main = do
    args <- getArgs
    prog <- getProgName

    case args of
        proofFile:cnfFile:_ -> do
            proof <- lines <$> readFile proofFile
            cnf   <- head . lines <$> readFile cnfFile

            case parseStrCNF cnf of
                Right clauses -> do
                    let assumptions = map (normalizeClause . factor) clauses
                    print $ check assumptions IM.empty proof
                _ -> error "main: cannot parse assumptions"

        _ -> putStrLn $ usage prog
  where
      usage p = intercalate "\n"
          [ "Usage: " ++ p ++ " PROOF-FILE CNF-FILE"
          , "Checks given proof. If the proof is correct program prints " ++
            "Nothing."
          , "Otherwise invalid step is shown or exception is thrown." ]

